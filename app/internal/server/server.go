package server

import (
	"context"
	"crypto/ed25519"
	"crypto/rsa"
	"crypto/x509"
	"fmt"
	"log/slog"
	"net/http"

	"github.com/go-chi/chi/v5"
	chimiddleware "github.com/go-chi/chi/v5/middleware"
	"github.com/information-sharing-networks/pint-demo/app/internal/config"
	"github.com/information-sharing-networks/pint-demo/app/internal/crypto"
	"github.com/information-sharing-networks/pint-demo/app/internal/database"
	"github.com/information-sharing-networks/pint-demo/app/internal/logger"
	"github.com/information-sharing-networks/pint-demo/app/internal/pint"
	pinthandlers "github.com/information-sharing-networks/pint-demo/app/internal/pint/pinthandlers"
	"github.com/information-sharing-networks/pint-demo/app/internal/server/handlers"
	"github.com/information-sharing-networks/pint-demo/app/internal/server/middleware"
	"github.com/information-sharing-networks/pint-demo/app/internal/services"
	"github.com/information-sharing-networks/pint-demo/app/internal/version"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/lestrrat-go/jwx/v3/jwk"
)

// Server contains the dependencies for the PINT server
type Server struct {
	// pool is the postgress database connection pool
	pool *pgxpool.Pool

	// queries is the database query interface (generated by sqlc)
	queries *database.Queries

	// config is the environment config
	config *config.ServerEnvironment

	// logger is the  default server logger
	logger *slog.Logger

	// router is the http router
	router *chi.Mux

	// platformCode is the DCSA platform code for this platform (e.g. "WAVE", "CARX", "EDOX")
	platformCode string

	// keyManager is the key manager for verifying public keys in JWS signatures
	// received from other platforms
	keyManager *pint.KeyManager

	// signingKey is the private key used for signing JWS signatures sent to other platforms
	// must be either ed25519.PrivateKey or *rsa.PrivateKey
	signingKey any

	// publicJWKSet is the JWK set containing the public key for this server's signing key
	// served at /.well-known/jwks.json (for public key discovery)
	publicJWKSet jwk.Set

	// x5cCertChain is the X.509 certificate chain included in JWS signatures sent to
	// other platforms (optional).
	x5cCertChain []*x509.Certificate

	// x5cCustomRoots is the custom root CAs for x5c verification (optional, nil = system roots).
	// the server can't be configured to use a custom root CA unless it is also
	// configured to include x5c headers in JWS signatures sent to other platforms.
	//
	// Note: if using a custom root, the server expects all participants in the PINT network that are using x5c headers
	// for non-repudation to share the same root CA
	x5cCustomRoots *x509.CertPool

	// services aggregates external service integrations (party validation, CTR, audit, etc.)
	services *services.Services
}

func NewServer(
	pool *pgxpool.Pool,
	queries *database.Queries,
	cfg *config.ServerEnvironment,
	logger *slog.Logger,
	ctx context.Context,
) (*Server, error) {
	server := &Server{
		pool:         pool,
		queries:      queries,
		config:       cfg,
		logger:       logger,
		router:       chi.NewRouter(),
		platformCode: cfg.PlatformCode,
	}

	// load signing key
	signingKey, err := crypto.ReadPrivateKeyFromJWKFile(cfg.SigningKeyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read signing key: %w", err)
	}

	logger.Info("loaded signing key",
		slog.String("path", cfg.SigningKeyPath),
		slog.String("type", fmt.Sprintf("%T", signingKey)))

	server.signingKey = signingKey

	// Load x5c certificate chain (if configured)
	if cfg.X5CCertPath != "" {
		certChain, err := crypto.ReadCertChainFromPEMFile(cfg.X5CCertPath)
		if err != nil {
			return nil, fmt.Errorf("failed to load x5c cert chain: %w", err)
		}
		server.x5cCertChain = certChain
		logger.Info("loaded x5c certificate chain",
			slog.String("path", cfg.X5CCertPath),
			slog.Int("certs", len(certChain)))
	}

	// configure root CAs
	if cfg.X5CCustomRootsPath == "" {
		logger.Info("using system root CAs for x5c validation")
	} else {
		server.x5cCustomRoots, err = crypto.LoadCustomRootCAs(cfg.X5CCustomRootsPath)
		if err != nil {
			return nil, fmt.Errorf("failed to load custom root CAs: %w", err)
		}
		logger.Info("loaded custom root CAs for x5c validation",
			slog.String("path", cfg.X5CCustomRootsPath))
	}

	// initialize key manager
	if err := server.initKeyManager(ctx); err != nil {
		return nil, fmt.Errorf("failed to initialize KeyManager: %w", err)
	}

	// create JWK set for JWKS endpoint
	jwkSet, err := server.createJWKSet()
	if err != nil {
		return nil, fmt.Errorf("failed to create JWK set: %w", err)
	}
	server.publicJWKSet = jwkSet

	// initialize services (party validation, etc)
	server.services, err = services.NewServices(cfg, queries)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize services: %w", err)
	}
	logger.Info("initialized services",
		slog.String("party_service_name", cfg.PartyServiceName),
		slog.String("party_service_base_url", cfg.PartyServiceBaseURL))

	// setup middleware
	server.setupMiddleware()

	// register routes
	server.registerCommonRoutes()
	server.registerApiDocoRoutes()
	server.registerPintRoutes()
	// admin routes are for development and testing only
	if cfg.Environment != "prod" && cfg.Environment != "staging" {
		server.registerAdminRoutes()
	}

	return server, nil
}

// initKeyManager creates and initializes the KeyManager.
func (s *Server) initKeyManager(ctx context.Context) error {

	s.logger.Info("DCSA registry URL",
		slog.String("url", s.config.RegistryPath))

	keyManagerConfig := pint.NewKeymanagerConfig(
		s.config.RegistryPath,
		s.config.ManualKeysDir,
		s.config.JWKCacheHTTPTimeout,
		s.config.SkipJWKCache,
		s.config.JWKCacheMinRefresh,
		s.config.JWKCacheMaxRefresh,
	)

	kmCtx, cancel := context.WithTimeout(ctx, s.config.RegistryFetchTimeout)
	defer cancel()

	keyManager, err := pint.NewKeyManager(kmCtx, keyManagerConfig, s.logger)
	if err != nil {
		return fmt.Errorf("failed to create KeyManager: %w", err)
	}

	s.keyManager = keyManager
	s.logger.Info("KeyManager initialized successfully")

	return nil
}

func (s *Server) setupMiddleware() {
	s.router.Use(chimiddleware.RequestID)
	s.router.Use(chimiddleware.RealIP)
	s.router.Use(chimiddleware.Recoverer)
	s.router.Use(logger.RequestLogging(s.logger))
	s.router.Use(middleware.SecurityHeaders(s.config.Environment))
	s.router.Use(middleware.RequestSizeLimit(s.config.MaxRequestSize)) // TODO - have separate limit for different routes?
	s.router.Use(middleware.RateLimit(s.config.RateLimitRPS, s.config.RateLimitBurst))

	// TODO: handle timeouts
	//s.router.Use(middleware.Timeout(60 * time.Second))
}

// registerCommonRoutes registers infrastructure routes (health, jwks, version, docs)
func (s *Server) registerCommonRoutes() {
	s.router.Get("/health/live", handlers.HandleHealth)
	s.router.Get("/ready", handlers.HandleReadiness(s.queries))
	s.router.Get("/.well-known/jwks.json", handlers.HandleJWKS(s.publicJWKSet))
	s.router.Get("/version", handlers.HandleVersion(version.Get().Version, version.Get().BuildDate))
}

func (s *Server) registerPintRoutes() {
	receiverValidation := pinthandlers.NewReceiverValidationHandler(
		s.services.PartyValidator,
	)

	startTransfer := pinthandlers.NewStartTransferHandler(
		s.queries,
		s.pool,
		s.platformCode,
		s.keyManager,
		s.signingKey,
		s.x5cCertChain,
		s.x5cCustomRoots,
		s.config.MinTrustLevel,
		s.services.PartyValidator,
	)

	transferAdditionalDocument := pinthandlers.NewTransferAdditionalDocumentHandler(
		s.queries,
		s.pool,
		s.signingKey,
		s.x5cCertChain,
	)

	finishEnvelopeTransfer := pinthandlers.NewFinishEnvelopeTransferHandler(
		s.queries,
		s.pool,
		s.signingKey,
		s.x5cCertChain,
	)

	s.router.Route("/v3", func(r chi.Router) {
		r.Post("/receiver-validation", receiverValidation.HandleReceiverValidation)
		r.Post("/envelopes", startTransfer.HandleStartTransfer)
		r.Put("/envelopes/{envelopeReference}/additional-documents/{documentChecksum}", transferAdditionalDocument.HandleTransferAdditionalDocument)
		r.Put("/envelopes/{envelopeReference}/finish-transfer", finishEnvelopeTransfer.HandleFinishEnvelopeTransfer)
	})
}

// registerApiDocoRoutes serves public static assets and API documentation
func (s *Server) registerApiDocoRoutes() {
	// API documentation routes
	s.router.Route("/", func(r chi.Router) {

		// API documentation (redoc)
		r.Get("/redoc", func(w http.ResponseWriter, r *http.Request) {
			http.ServeFile(w, r, "./docs/redoc.html")
		})

		// API documentation (rapidocs)
		r.Get("/docs", func(w http.ResponseWriter, r *http.Request) {
			http.ServeFile(w, r, "./docs/rapidoc.html")
		})
		// OpenAPI specification for API clients and tools
		r.Get("/swagger.json", func(w http.ResponseWriter, r *http.Request) {
			http.ServeFile(w, r, "./docs/swagger.json")
		})
	})
}

// registerAdminRoutes registers admin API routes for managing parties
func (s *Server) registerAdminRoutes() {
	s.router.Route("/admin", func(r chi.Router) {
		// Party management
		r.Post("/parties", handlers.HandleCreateParty(s.queries))
		r.Get("/parties/{partyID}", handlers.HandleGetPartyByID(s.queries))
		r.Put("/parties/{partyID}", handlers.HandleUpdateParty(s.queries))
		r.Get("/parties/{partyName}", handlers.HandleGetPartyByPartyName(s.queries))
		r.Post("/parties/{partyID}/codes", handlers.HandleCreatePartyIdentifyingCode(s.queries))
		// Party lookup by code (used by local party validator)
		r.Get("/parties", handlers.HandleGetPartyByPartyCode(s.queries))
	})
}

func (s *Server) DatabaseShutdown() {
	if s.pool != nil {
		s.pool.Close()
		s.logger.Info("database connection closed")
	}
}

// CreateJWKSet creates a JWK set from the server's signing key's PUBLIC key.
// The JWKS endpoint must only expose public keys, never private keys.
func (s *Server) createJWKSet() (jwk.Set, error) {
	var jwkKey jwk.Key
	var err error

	switch key := s.signingKey.(type) {
	case ed25519.PrivateKey:
		// Extract public key from private key
		publicKey := key.Public().(ed25519.PublicKey)
		jwkKey, err = crypto.Ed25519PublicKeyToJWK(publicKey)
		if err != nil {
			return nil, fmt.Errorf("failed to create Ed25519 public JWK: %w", err)
		}
	case *rsa.PrivateKey:
		// Extract public key from private key
		publicKey := &key.PublicKey
		jwkKey, err = crypto.RSAPublicKeyToJWK(publicKey)
		if err != nil {
			return nil, fmt.Errorf("failed to create RSA public JWK: %w", err)
		}
	default:
		return nil, fmt.Errorf("unsupported key type: %T", key)
	}

	jwkSet := jwk.NewSet()
	if err := jwkSet.AddKey(jwkKey); err != nil {
		return nil, fmt.Errorf("failed to add key to JWK set: %w", err)
	}

	return jwkSet, nil
}

// Start starts the server and shuts down gracefully when the context is cancelled.
func (s *Server) Start(ctx context.Context) error {
	serverAddr := fmt.Sprintf("%s:%d", s.config.Host, s.config.Port)

	httpServer := &http.Server{
		Addr:         serverAddr,
		Handler:      s.router,
		ReadTimeout:  s.config.ReadTimeout,
		WriteTimeout: s.config.WriteTimeout,
		IdleTimeout:  s.config.IdleTimeout,
	}

	serverErrors := make(chan error, 1)

	go func() {
		s.logger.Info("service listening",
			slog.String("environment", s.config.Environment),
			slog.String("address", serverAddr))

		err := httpServer.ListenAndServe()
		if err != nil && err != http.ErrServerClosed {
			serverErrors <- fmt.Errorf("server failed to start: %w", err)
		}
	}()

	select {
	case err := <-serverErrors:
		return err
	case <-ctx.Done():
		s.logger.Info("shutdown signal received")
	}

	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), s.config.ServerShutdownTimeout)
	defer shutdownCancel()

	s.logger.Info("shutting down HTTP server")

	err := httpServer.Shutdown(shutdownCtx)
	if err != nil {
		s.logger.Warn("HTTP server shutdown error",
			slog.String("error", err.Error()))
		return fmt.Errorf("HTTP server shutdown failed: %w", err)
	}

	s.logger.Info("HTTP server shutdown complete")
	return nil
}
