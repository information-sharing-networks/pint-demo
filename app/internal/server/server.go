package server

import (
	"context"
	"crypto/x509"
	"fmt"
	"log/slog"
	"net/http"

	"github.com/go-chi/chi/v5"
	chimiddleware "github.com/go-chi/chi/v5/middleware"
	"github.com/information-sharing-networks/pint-demo/app/internal/config"
	"github.com/information-sharing-networks/pint-demo/app/internal/crypto"
	"github.com/information-sharing-networks/pint-demo/app/internal/database"
	"github.com/information-sharing-networks/pint-demo/app/internal/pint"
	"github.com/information-sharing-networks/pint-demo/app/internal/pint/handlers"
	"github.com/information-sharing-networks/pint-demo/app/internal/server/middleware"
	"github.com/jackc/pgx/v5/pgxpool"
)

type Server struct {
	// pool is the postgress database connection pool
	pool *pgxpool.Pool

	// queries is the database query interface (generated by sqlc)
	queries *database.Queries

	// config is the environment config
	config *config.ServerEnvironment

	// logger is the  default server logger
	logger *slog.Logger

	// router is the http router
	router *chi.Mux

	// keyManager is the key manager for verifying public keys in JWS signatures
	// received from other platforms
	keyManager *pint.KeyManager

	// signingKey is the private key used for signing JWS signatures sent to other platforms
	// must be either ed25519.PrivateKey or *rsa.PrivateKey
	signingKey any

	// x5cCertChain is the X.509 certificate chain included in JWS signatures sent to
	// other platforms (optional).
	x5cCertChain []*x509.Certificate // X.509 certificate chain for signing (optional)

	// x5cCustomRoots is the custom root CAs for x5c verification (optional, nil = system roots).
	// the server can't be configured to use a custom root CA unless it is also
	// configured to include x5c headers in JWS signatures sent to other platforms.
	//
	// Note: if using a custom root, the server expects all participants in the PINT network that are using x5c headers
	// for non-repudation to share the same root CA
	x5cCustomRoots *x509.CertPool // Custom root CAs for x5c verification (optional, nil = system roots)
}

func NewServer(
	pool *pgxpool.Pool,
	queries *database.Queries,
	cfg *config.ServerEnvironment,
	logger *slog.Logger,
	ctx context.Context,
) (*Server, error) {
	server := &Server{
		pool:   pool,
		config: cfg,
		logger: logger,
		router: chi.NewRouter(),
	}

	// load signing key
	signingKey, err := crypto.ReadPrivateKeyFromJWKFile(cfg.SigningKeyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read signing key: %w", err)
	}

	logger.Info("loaded signing key",
		slog.String("path", cfg.SigningKeyPath),
		slog.String("type", fmt.Sprintf("%T", signingKey)))

	server.signingKey = signingKey

	// Load x5c certificate chain (if configured)
	if cfg.X5CCertPath != "" {
		certChain, err := crypto.ReadCertChainFromPEMFile(cfg.X5CCertPath)
		if err != nil {
			return nil, fmt.Errorf("failed to load x5c cert chain: %w", err)
		}
		server.x5cCertChain = certChain
		logger.Info("loaded x5c certificate chain",
			slog.String("path", cfg.X5CCertPath),
			slog.Int("certs", len(certChain)))
	}

	// configure root CAs for validating JWS signatures
	if cfg.X5CCustomRootsPath == "" {
		logger.Info("using system root CAs for x5c validation")
	} else {
		server.x5cCustomRoots, err = crypto.LoadCustomRootCAs(cfg.X5CCustomRootsPath)
		if err != nil {
			return nil, fmt.Errorf("failed to load custom root CAs: %w", err)
		}
		logger.Info("loaded custom root CAs for x5c validation",
			slog.String("path", cfg.X5CCustomRootsPath))
	}

	// initialize key manager
	if err := server.initKeyManager(ctx); err != nil {
		return nil, fmt.Errorf("failed to initialize KeyManager: %w", err)
	}

	// setup middleware and routes
	server.setupMiddleware()
	server.registerRoutes()

	return server, nil
}

// initKeyManager creates and initializes the KeyManager.
func (s *Server) initKeyManager(ctx context.Context) error {

	s.logger.Info("DCSA registry URL",
		slog.String("url", s.config.RegistryPath))

	keyManagerConfig := pint.NewKeymanagerConfig(
		s.config.RegistryPath,
		s.config.ManualKeysDir,
		s.config.JWKCacheHTTPTimeout,
		s.config.SkipJWKCache,
		s.config.JWKCacheMinRefresh,
		s.config.JWKCacheMaxRefresh,
	)

	kmCtx, cancel := context.WithTimeout(ctx, s.config.RegistryFetchTimeout)
	defer cancel()

	keyManager, err := pint.NewKeyManager(kmCtx, keyManagerConfig, s.logger)
	if err != nil {
		return fmt.Errorf("failed to create KeyManager: %w", err)
	}

	s.keyManager = keyManager
	s.logger.Info("KeyManager initialized successfully")

	return nil
}

func (s *Server) setupMiddleware() {
	s.router.Use(chimiddleware.RequestID)
	s.router.Use(chimiddleware.RealIP)
	s.router.Use(chimiddleware.Recoverer)
	s.router.Use(middleware.SecurityHeaders(s.config.Environment))
	s.router.Use(middleware.RequestSizeLimit(s.config.MaxRequestSize)) // TODO - have separate limit for different routes?
	s.router.Use(middleware.RateLimit(s.config.RateLimitRPS, s.config.RateLimitBurst))

	// TODO: handle timeouts
	//s.router.Use(middleware.Timeout(60 * time.Second))
}

func (s *Server) registerRoutes() {

	s.router.Get("/health", s.handleHealth)

	// Create handlers with dependencies
	startTransferHandler := handlers.NewStartTransferHandler(
		s.queries,
		s.keyManager,
		s.signingKey,
		s.x5cCertChain,
		s.x5cCustomRoots,
	)

	s.router.Route("/v3", func(r chi.Router) {
		r.Post("/receiver-validation", s.handleReceiverValidation)
		r.Post("/envelopes", startTransferHandler.HandleStartTransfer)
		r.Put("/envelopes/{envelopeReference}/additional-documents/{documentChecksum}", s.handleTransferAdditionalDocument)
		r.Put("/envelopes/{envelopeReference}/finish-transfer", s.handleFinishEnvelopeTransfer)
	})

	s.router.Get("/.well-known/jwks.json", s.handleJWKS)
}

func (s *Server) Start(ctx context.Context) error {
	serverAddr := fmt.Sprintf("%s:%d", s.config.Host, s.config.Port)

	httpServer := &http.Server{
		Addr:         serverAddr,
		Handler:      s.router,
		ReadTimeout:  s.config.ReadTimeout,
		WriteTimeout: s.config.WriteTimeout,
		IdleTimeout:  s.config.IdleTimeout,
	}

	serverErrors := make(chan error, 1)

	go func() {
		s.logger.Info("service listening",
			slog.String("environment", s.config.Environment),
			slog.String("address", serverAddr))

		err := httpServer.ListenAndServe()
		if err != nil && err != http.ErrServerClosed {
			serverErrors <- fmt.Errorf("server failed to start: %w", err)
		}
	}()

	select {
	case err := <-serverErrors:
		return err
	case <-ctx.Done():
		s.logger.Info("shutdown signal received")
	}

	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), s.config.ServerShutdownTimeout)
	defer shutdownCancel()

	s.logger.Info("shutting down HTTP server")

	err := httpServer.Shutdown(shutdownCtx)
	if err != nil {
		s.logger.Warn("HTTP server shutdown error",
			slog.String("error", err.Error()))
		return fmt.Errorf("HTTP server shutdown failed: %w", err)
	}

	s.logger.Info("HTTP server shutdown complete")
	return nil
}

func (s *Server) DatabaseShutdown() {
	if s.pool != nil {
		s.pool.Close()
		s.logger.Info("database connection closed")
	}
}

// TODO - c.f signalsd
func (s *Server) handleHealth(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write([]byte(`{"status":"healthy"}`))
}

func (s *Server) handleReceiverValidation(w http.ResponseWriter, r *http.Request) {
	http.Error(w, "Not implemented", http.StatusNotImplemented)
}

func (s *Server) handleTransferAdditionalDocument(w http.ResponseWriter, r *http.Request) {
	http.Error(w, "Not implemented", http.StatusNotImplemented)
}

func (s *Server) handleFinishEnvelopeTransfer(w http.ResponseWriter, r *http.Request) {
	http.Error(w, "Not implemented", http.StatusNotImplemented)
}

// handleJWKS serves the JSON Web Key Set at /.well-known/jwks.json
func (s *Server) handleJWKS(w http.ResponseWriter, r *http.Request) {
	http.Error(w, "Not implemented", http.StatusNotImplemented)
}
