// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: envelopes.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateEnvelope = `-- name: CreateEnvelope :one
INSERT INTO envelopes (
    id,
    created_at,
    transport_document_checksum,
    action_code,
    last_transfer_chain_entry_signed_content_payload_checksum,
    sent_by_platform_code,
    received_by_platform_code,
    envelope_manifest_signed_content,
    last_transfer_chain_entry_signed_content_checksum,
    last_transfer_chain_entry_signed_content,
    trust_level
) VALUES (
    gen_random_uuid(),
    NOW(),
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
) RETURNING id, created_at, accepted_at, transport_document_checksum, last_transfer_chain_entry_signed_content_payload_checksum, last_transfer_chain_entry_signed_content_checksum, action_code, sent_by_platform_code, received_by_platform_code, envelope_manifest_signed_content, last_transfer_chain_entry_signed_content, trust_level
`

type CreateEnvelopeParams struct {
	TransportDocumentChecksum                          string `json:"transport_document_checksum"`
	ActionCode                                         string `json:"action_code"`
	LastTransferChainEntrySignedContentPayloadChecksum string `json:"last_transfer_chain_entry_signed_content_payload_checksum"`
	SentByPlatformCode                                 string `json:"sent_by_platform_code"`
	ReceivedByPlatformCode                             string `json:"received_by_platform_code"`
	EnvelopeManifestSignedContent                      string `json:"envelope_manifest_signed_content"`
	LastTransferChainEntrySignedContentChecksum        string `json:"last_transfer_chain_entry_signed_content_checksum"`
	LastTransferChainEntrySignedContent                string `json:"last_transfer_chain_entry_signed_content"`
	TrustLevel                                         int32  `json:"trust_level"`
}

// Create a new envelope record for a transfer session if it doen't already exist.
// A new envelope transfer is created for every new transfer chain entry received
// (based on the checksum of the payload of the last transfer chain entry JWS token)
// envelopes.id is used as the envelope reference in the API responses.
func (q *Queries) CreateEnvelope(ctx context.Context, arg CreateEnvelopeParams) (Envelope, error) {
	row := q.db.QueryRow(ctx, CreateEnvelope,
		arg.TransportDocumentChecksum,
		arg.ActionCode,
		arg.LastTransferChainEntrySignedContentPayloadChecksum,
		arg.SentByPlatformCode,
		arg.ReceivedByPlatformCode,
		arg.EnvelopeManifestSignedContent,
		arg.LastTransferChainEntrySignedContentChecksum,
		arg.LastTransferChainEntrySignedContent,
		arg.TrustLevel,
	)
	var i Envelope
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.AcceptedAt,
		&i.TransportDocumentChecksum,
		&i.LastTransferChainEntrySignedContentPayloadChecksum,
		&i.LastTransferChainEntrySignedContentChecksum,
		&i.ActionCode,
		&i.SentByPlatformCode,
		&i.ReceivedByPlatformCode,
		&i.EnvelopeManifestSignedContent,
		&i.LastTransferChainEntrySignedContent,
		&i.TrustLevel,
	)
	return i, err
}

const ExistsEnvelopeByLastChainEntrySignedContentPayloadChecksum = `-- name: ExistsEnvelopeByLastChainEntrySignedContentPayloadChecksum :one
SELECT EXISTS(
    SELECT 1 FROM envelopes 
    WHERE last_transfer_chain_entry_signed_content_payload_checksum = $1
)
`

// last_transfer_chain_entry_signed_content_payload_checksum is the checksum of the payload of the last transfer chain entry JWS token
// and is unique for each transfer attempt
func (q *Queries) ExistsEnvelopeByLastChainEntrySignedContentPayloadChecksum(ctx context.Context, lastTransferChainEntrySignedContentPayloadChecksum string) (bool, error) {
	row := q.db.QueryRow(ctx, ExistsEnvelopeByLastChainEntrySignedContentPayloadChecksum, lastTransferChainEntrySignedContentPayloadChecksum)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const GetEnvelopeByLastChainEntrySignedContentPayloadChecksum = `-- name: GetEnvelopeByLastChainEntrySignedContentPayloadChecksum :one
SELECT id, created_at, accepted_at, transport_document_checksum, last_transfer_chain_entry_signed_content_payload_checksum, last_transfer_chain_entry_signed_content_checksum, action_code, sent_by_platform_code, received_by_platform_code, envelope_manifest_signed_content, last_transfer_chain_entry_signed_content, trust_level,
    (accepted_at IS NOT NULL)::bool AS accepted 
FROM envelopes 
WHERE last_transfer_chain_entry_signed_content_payload_checksum = $1
`

type GetEnvelopeByLastChainEntrySignedContentPayloadChecksumRow struct {
	ID                                                 uuid.UUID          `json:"id"`
	CreatedAt                                          pgtype.Timestamptz `json:"created_at"`
	AcceptedAt                                         pgtype.Timestamptz `json:"accepted_at"`
	TransportDocumentChecksum                          string             `json:"transport_document_checksum"`
	LastTransferChainEntrySignedContentPayloadChecksum string             `json:"last_transfer_chain_entry_signed_content_payload_checksum"`
	LastTransferChainEntrySignedContentChecksum        string             `json:"last_transfer_chain_entry_signed_content_checksum"`
	ActionCode                                         string             `json:"action_code"`
	SentByPlatformCode                                 string             `json:"sent_by_platform_code"`
	ReceivedByPlatformCode                             string             `json:"received_by_platform_code"`
	EnvelopeManifestSignedContent                      string             `json:"envelope_manifest_signed_content"`
	LastTransferChainEntrySignedContent                string             `json:"last_transfer_chain_entry_signed_content"`
	TrustLevel                                         int32              `json:"trust_level"`
	Accepted                                           bool               `json:"accepted"`
}

// last_transfer_chain_entry_signed_content_payload_checksum is the checksum of the payload of the last transfer chain entry JWS token
// and is unique for each transfer attempt
func (q *Queries) GetEnvelopeByLastChainEntrySignedContentPayloadChecksum(ctx context.Context, lastTransferChainEntrySignedContentPayloadChecksum string) (GetEnvelopeByLastChainEntrySignedContentPayloadChecksumRow, error) {
	row := q.db.QueryRow(ctx, GetEnvelopeByLastChainEntrySignedContentPayloadChecksum, lastTransferChainEntrySignedContentPayloadChecksum)
	var i GetEnvelopeByLastChainEntrySignedContentPayloadChecksumRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.AcceptedAt,
		&i.TransportDocumentChecksum,
		&i.LastTransferChainEntrySignedContentPayloadChecksum,
		&i.LastTransferChainEntrySignedContentChecksum,
		&i.ActionCode,
		&i.SentByPlatformCode,
		&i.ReceivedByPlatformCode,
		&i.EnvelopeManifestSignedContent,
		&i.LastTransferChainEntrySignedContent,
		&i.TrustLevel,
		&i.Accepted,
	)
	return i, err
}

const GetEnvelopeByReference = `-- name: GetEnvelopeByReference :one
SELECT id, created_at, accepted_at, transport_document_checksum, last_transfer_chain_entry_signed_content_payload_checksum, last_transfer_chain_entry_signed_content_checksum, action_code, sent_by_platform_code, received_by_platform_code, envelope_manifest_signed_content, last_transfer_chain_entry_signed_content, trust_level FROM envelopes 
WHERE id = $1
`

// Get envelope by envelope reference (id)
func (q *Queries) GetEnvelopeByReference(ctx context.Context, id uuid.UUID) (Envelope, error) {
	row := q.db.QueryRow(ctx, GetEnvelopeByReference, id)
	var i Envelope
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.AcceptedAt,
		&i.TransportDocumentChecksum,
		&i.LastTransferChainEntrySignedContentPayloadChecksum,
		&i.LastTransferChainEntrySignedContentChecksum,
		&i.ActionCode,
		&i.SentByPlatformCode,
		&i.ReceivedByPlatformCode,
		&i.EnvelopeManifestSignedContent,
		&i.LastTransferChainEntrySignedContent,
		&i.TrustLevel,
	)
	return i, err
}

const MarkEnvelopeAccepted = `-- name: MarkEnvelopeAccepted :exec
UPDATE envelopes
SET accepted_at = NOW()
WHERE id = $1 AND accepted_at IS NULL
`

// Mark an envelope as accepted by setting accepted_at timestamp
func (q *Queries) MarkEnvelopeAccepted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, MarkEnvelopeAccepted, id)
	return err
}
