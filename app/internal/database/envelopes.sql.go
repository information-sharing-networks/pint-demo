// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: envelopes.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const CreateEnvelope = `-- name: CreateEnvelope :one
INSERT INTO envelopes (
    id,
    created_at,
    updated_at,
    transport_document_checksum,
    action_code,
    last_transfer_chain_entry_signed_content_payload_checksum,
    sent_by_platform_code,
    envelope_manifest_signed_content,
    last_transfer_chain_entry_signed_content_checksum,
    last_transfer_chain_entry_signed_content,
    trust_level
) VALUES (
    gen_random_uuid(),
    NOW(),
    NOW(),
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
) RETURNING id, created_at, updated_at, transport_document_checksum, last_transfer_chain_entry_signed_content_payload_checksum, last_transfer_chain_entry_signed_content_checksum, action_code, sent_by_platform_code, envelope_manifest_signed_content, last_transfer_chain_entry_signed_content, trust_level, accepted_at
`

type CreateEnvelopeParams struct {
	TransportDocumentChecksum                          string `json:"transport_document_checksum"`
	ActionCode                                         string `json:"action_code"`
	LastTransferChainEntrySignedContentPayloadChecksum string `json:"last_transfer_chain_entry_signed_content_payload_checksum"`
	SentByPlatformCode                                 string `json:"sent_by_platform_code"`
	EnvelopeManifestSignedContent                      string `json:"envelope_manifest_signed_content"`
	LastTransferChainEntrySignedContentChecksum        string `json:"last_transfer_chain_entry_signed_content_checksum"`
	LastTransferChainEntrySignedContent                string `json:"last_transfer_chain_entry_signed_content"`
	TrustLevel                                         int32  `json:"trust_level"`
}

// Create a new envelope record for a transfer session if it doen't already exist.
// A new envelope transfer is created for every new transfer chain entry received
// (based on the checksum of the payload of the last transfer chain entry JWS token)
// envelopes.id is used as the envelope reference in the API responses.
func (q *Queries) CreateEnvelope(ctx context.Context, arg CreateEnvelopeParams) (Envelope, error) {
	row := q.db.QueryRow(ctx, CreateEnvelope,
		arg.TransportDocumentChecksum,
		arg.ActionCode,
		arg.LastTransferChainEntrySignedContentPayloadChecksum,
		arg.SentByPlatformCode,
		arg.EnvelopeManifestSignedContent,
		arg.LastTransferChainEntrySignedContentChecksum,
		arg.LastTransferChainEntrySignedContent,
		arg.TrustLevel,
	)
	var i Envelope
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransportDocumentChecksum,
		&i.LastTransferChainEntrySignedContentPayloadChecksum,
		&i.LastTransferChainEntrySignedContentChecksum,
		&i.ActionCode,
		&i.SentByPlatformCode,
		&i.EnvelopeManifestSignedContent,
		&i.LastTransferChainEntrySignedContent,
		&i.TrustLevel,
		&i.AcceptedAt,
	)
	return i, err
}

const ExistsEnvelopeByLastChainEntrySignedContentPayloadChecksum = `-- name: ExistsEnvelopeByLastChainEntrySignedContentPayloadChecksum :one
SELECT EXISTS(
    SELECT 1 FROM envelopes 
    WHERE last_transfer_chain_entry_signed_content_payload_checksum = $1
)
`

// last_transfer_chain_entry_signed_content_payload_checksum is the checksum of the payload of the last transfer chain entry JWS token
// and is unique for each transfer attempt
func (q *Queries) ExistsEnvelopeByLastChainEntrySignedContentPayloadChecksum(ctx context.Context, lastTransferChainEntrySignedContentPayloadChecksum string) (bool, error) {
	row := q.db.QueryRow(ctx, ExistsEnvelopeByLastChainEntrySignedContentPayloadChecksum, lastTransferChainEntrySignedContentPayloadChecksum)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const GetEnvelopeByLastChainEntrySignedContentPayloadChecksum = `-- name: GetEnvelopeByLastChainEntrySignedContentPayloadChecksum :one
SELECT id, created_at, updated_at, transport_document_checksum, last_transfer_chain_entry_signed_content_payload_checksum, last_transfer_chain_entry_signed_content_checksum, action_code, sent_by_platform_code, envelope_manifest_signed_content, last_transfer_chain_entry_signed_content, trust_level, accepted_at FROM envelopes 
WHERE last_transfer_chain_entry_signed_content_payload_checksum = $1
`

// last_transfer_chain_entry_signed_content_payload_checksum is the checksum of the payload of the last transfer chain entry JWS token
// and is unique for each transfer attempt
func (q *Queries) GetEnvelopeByLastChainEntrySignedContentPayloadChecksum(ctx context.Context, lastTransferChainEntrySignedContentPayloadChecksum string) (Envelope, error) {
	row := q.db.QueryRow(ctx, GetEnvelopeByLastChainEntrySignedContentPayloadChecksum, lastTransferChainEntrySignedContentPayloadChecksum)
	var i Envelope
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransportDocumentChecksum,
		&i.LastTransferChainEntrySignedContentPayloadChecksum,
		&i.LastTransferChainEntrySignedContentChecksum,
		&i.ActionCode,
		&i.SentByPlatformCode,
		&i.EnvelopeManifestSignedContent,
		&i.LastTransferChainEntrySignedContent,
		&i.TrustLevel,
		&i.AcceptedAt,
	)
	return i, err
}

const GetEnvelopeByReference = `-- name: GetEnvelopeByReference :one
SELECT id, created_at, updated_at, transport_document_checksum, last_transfer_chain_entry_signed_content_payload_checksum, last_transfer_chain_entry_signed_content_checksum, action_code, sent_by_platform_code, envelope_manifest_signed_content, last_transfer_chain_entry_signed_content, trust_level, accepted_at FROM envelopes 
WHERE id = $1
`

// Get envelope by envelope reference (id)
func (q *Queries) GetEnvelopeByReference(ctx context.Context, id uuid.UUID) (Envelope, error) {
	row := q.db.QueryRow(ctx, GetEnvelopeByReference, id)
	var i Envelope
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransportDocumentChecksum,
		&i.LastTransferChainEntrySignedContentPayloadChecksum,
		&i.LastTransferChainEntrySignedContentChecksum,
		&i.ActionCode,
		&i.SentByPlatformCode,
		&i.EnvelopeManifestSignedContent,
		&i.LastTransferChainEntrySignedContent,
		&i.TrustLevel,
		&i.AcceptedAt,
	)
	return i, err
}

const MarkEnvelopeAccepted = `-- name: MarkEnvelopeAccepted :exec
UPDATE envelopes
SET accepted_at = NOW()
WHERE id = $1 AND accepted_at IS NULL
`

// Mark an envelope as accepted by setting accepted_at timestamp
func (q *Queries) MarkEnvelopeAccepted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, MarkEnvelopeAccepted, id)
	return err
}
