// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: envelopes.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const CreateEnvelopeIfNew = `-- name: CreateEnvelopeIfNew :one
INSERT INTO envelopes (
    id,
    created_at,
    updated_at,
    transport_document_checksum,
    envelope_state,
    sent_by_platform_code,
    last_transfer_chain_entry_checksum,
    envelope_manifest_signed_content,
    last_transfer_chain_entry_signed_content,
    trust_level
) VALUES (
    gen_random_uuid(),
    NOW(),
    NOW(),
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
) ON CONFLICT (last_transfer_chain_entry_checksum, envelope_state) DO NOTHING RETURNING id, created_at, updated_at, transport_document_checksum, envelope_state, sent_by_platform_code, last_transfer_chain_entry_checksum, envelope_manifest_signed_content, last_transfer_chain_entry_signed_content, trust_level, accepted_at
`

type CreateEnvelopeIfNewParams struct {
	TransportDocumentChecksum           string `json:"transport_document_checksum"`
	EnvelopeState                       string `json:"envelope_state"`
	SentByPlatformCode                  string `json:"sent_by_platform_code"`
	LastTransferChainEntryChecksum      string `json:"last_transfer_chain_entry_checksum"`
	EnvelopeManifestSignedContent       string `json:"envelope_manifest_signed_content"`
	LastTransferChainEntrySignedContent string `json:"last_transfer_chain_entry_signed_content"`
	TrustLevel                          int32  `json:"trust_level"`
}

// Create a new envelope record for a transfer session if it doen't already exist for the current envelope state
func (q *Queries) CreateEnvelopeIfNew(ctx context.Context, arg CreateEnvelopeIfNewParams) (Envelope, error) {
	row := q.db.QueryRow(ctx, CreateEnvelopeIfNew,
		arg.TransportDocumentChecksum,
		arg.EnvelopeState,
		arg.SentByPlatformCode,
		arg.LastTransferChainEntryChecksum,
		arg.EnvelopeManifestSignedContent,
		arg.LastTransferChainEntrySignedContent,
		arg.TrustLevel,
	)
	var i Envelope
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransportDocumentChecksum,
		&i.EnvelopeState,
		&i.SentByPlatformCode,
		&i.LastTransferChainEntryChecksum,
		&i.EnvelopeManifestSignedContent,
		&i.LastTransferChainEntrySignedContent,
		&i.TrustLevel,
		&i.AcceptedAt,
	)
	return i, err
}

const ExistsEnvelopeByLastChainEntryChecksum = `-- name: ExistsEnvelopeByLastChainEntryChecksum :one
SELECT EXISTS(
    SELECT 1 FROM envelopes 
    WHERE last_transfer_chain_entry_checksum = $1
)
`

// Check if an transfer with this last_transfer_chain_entry_checksum already exists
func (q *Queries) ExistsEnvelopeByLastChainEntryChecksum(ctx context.Context, lastTransferChainEntryChecksum string) (bool, error) {
	row := q.db.QueryRow(ctx, ExistsEnvelopeByLastChainEntryChecksum, lastTransferChainEntryChecksum)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const GetEnvelopeByLastChainEntryChecksum = `-- name: GetEnvelopeByLastChainEntryChecksum :one
SELECT id, created_at, updated_at, transport_document_checksum, envelope_state, sent_by_platform_code, last_transfer_chain_entry_checksum, envelope_manifest_signed_content, last_transfer_chain_entry_signed_content, trust_level, accepted_at FROM envelopes 
WHERE last_transfer_chain_entry_checksum = $1
`

func (q *Queries) GetEnvelopeByLastChainEntryChecksum(ctx context.Context, lastTransferChainEntryChecksum string) (Envelope, error) {
	row := q.db.QueryRow(ctx, GetEnvelopeByLastChainEntryChecksum, lastTransferChainEntryChecksum)
	var i Envelope
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransportDocumentChecksum,
		&i.EnvelopeState,
		&i.SentByPlatformCode,
		&i.LastTransferChainEntryChecksum,
		&i.EnvelopeManifestSignedContent,
		&i.LastTransferChainEntrySignedContent,
		&i.TrustLevel,
		&i.AcceptedAt,
	)
	return i, err
}

const GetEnvelopeByReference = `-- name: GetEnvelopeByReference :one
SELECT id, created_at, updated_at, transport_document_checksum, envelope_state, sent_by_platform_code, last_transfer_chain_entry_checksum, envelope_manifest_signed_content, last_transfer_chain_entry_signed_content, trust_level, accepted_at FROM envelopes 
WHERE id = $1
`

// Get envelope by envelope reference (id)
func (q *Queries) GetEnvelopeByReference(ctx context.Context, id uuid.UUID) (Envelope, error) {
	row := q.db.QueryRow(ctx, GetEnvelopeByReference, id)
	var i Envelope
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransportDocumentChecksum,
		&i.EnvelopeState,
		&i.SentByPlatformCode,
		&i.LastTransferChainEntryChecksum,
		&i.EnvelopeManifestSignedContent,
		&i.LastTransferChainEntrySignedContent,
		&i.TrustLevel,
		&i.AcceptedAt,
	)
	return i, err
}

const MarkEnvelopeAccepted = `-- name: MarkEnvelopeAccepted :exec
UPDATE envelopes
SET accepted_at = NOW()
WHERE id = $1 AND accepted_at IS NULL
`

// Mark an envelope as accepted by setting accepted_at timestamp
func (q *Queries) MarkEnvelopeAccepted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, MarkEnvelopeAccepted, id)
	return err
}
